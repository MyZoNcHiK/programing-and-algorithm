//Дано масив із N цілих чисел. Знайти найбільшу суму підмасивів довільної довжини, де елементи йдуть підряд

//Ця задача розв'язана навіть без gpt, за допомогою алгоритму Кадане, подібні задачі мені зустрілися кілька разів тому думаю пригодиться на олімпіаді
//Працює ця ху*** наступним чином: 
#include<iostream>
#include<vector>
using namespace std;

int main(){
    int N;
    cout << "Введіть розмір масиву" << endl;
    cin >> N;
    vector<int> a(N);
    cout << "Введіть елементи масиву" << endl;
    for(int i=0; i<N;i++){ cin >> a[i];} //просто вхідний масив
    int current = a[0], max = a[0], start = 0, bestStart = 0, bestEnd = 0; //змінні старт та найкращі страрт і кінець потрібні просто для того щоб вивести підмасив, насправді до розв'язку задачі вони не мають жодного значення, тому їх можна проігнорувати
    for(int i=0; i<N;i++){ //для кожного алемента масиву
        if(current <= 0){ //перевіряємо чи зараз сума пішла в мінус
            current = a[i]; //якщо пішла то починаємо наступний підмасив з іншого елемента, потім знову перевіряємо чи вигідний він, і так по всіх елемнтах
            start = i; 
        } else {
            current += a[i]; //якщо сума виявилась вигідна, тобто не пішла в мінус то просто додаємо наступний елемент до суми і знову ж таки перевіряємо чи сума стане від цього не вигідною, чи ні
        }
        if(current > max){ //якщо сума яка в нає є зараз більша за записану максимальну то перезаписуємо максимульну, тут все елементарно
            max = current;
            bestStart = start;
            bestEnd = i;
        }
    }  
    cout << "Найбільша сума: " << max << endl;
    cout << "Підмасив: " << endl;
    for (int i = bestStart; i <= bestEnd; i++){
        cout << a[i] << " ";
    }
    cout << endl;
}
//Чесно, інтуїція весь час каже, та не може така хуйня працювати, а потім підставляєш різні числа, даєш умови де всі числа від'ємні, або тому подібне і виявляється, що це якогось х** реально працює
